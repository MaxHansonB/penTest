"""main.py file that runs the whole program. When run, it will populate a pddl problem
file based on the specified attack graph configuration (# of nodes, connection prob, seed).
You can comment-in and run the cases at the bottom if you want to see the program in acton.
"""

from graph import generate_attack_graph


def pddlify_problem(nodes, graph_con_prob, bayes_seed=None, graph_seed=None,
                    start=None, goal=None, display=False):
    """This function uses the tools from graphy.py to create an attack graph.
    Then it converts the setup into a pddl problem file, to be used in conjunction
    with my domain.pddl file. Note: if no start or goal is set, the 0th node will
    be selected as the start, and the n-1th node will be selected as the goal.

    :param nodes: Number of host-nodes to include.
    :param graph_con_prob: The probability of connections between nodes.
    :param bayes_seed: Seed for the random sampling of the host-configuration Bayes Net.
    :param graph_seed: Seed for the random generation of the graph network.
    :param start: Optional parameter to specify the start node (by node index 0-n).
    :param goal: Optional parameter to specify the goal node (by node index 0-n).
    :param display: Whether to display attack graph and associated info (host configs).
    :return: None, but pddl file is written.
    """
    # Generate attack graph
    atk_graph = generate_attack_graph(nodes, graph_con_prob,
                                      bayes_seed=bayes_seed,
                                      graph_seed=graph_seed,
                                      start=start,
                                      goal=goal,
                                      display=display)

    # Query attack-graph nodes to identify nodes with relevant properties
    # We need this information to define objects, predicates and initial state
    all_nodes = list(atk_graph.nodes())
    start_node = [n for n, v in atk_graph.nodes(data=True) if v['Start'] == 1][0]
    goal_node = [n for n, v in atk_graph.nodes(data=True) if v['Goal'] == 1][0]
    windows_nodes = [n for n, v in atk_graph.nodes(data=True) if v['OS'] == 0]
    mac_nodes = [n for n, v in atk_graph.nodes(data=True) if v['OS'] == 1]
    linux_nodes = [n for n, v in atk_graph.nodes(data=True) if v['OS'] == 2]
    x86_nodes = [n for n, v in atk_graph.nodes(data=True) if v['x86_Arch'] == 1]
    arm_nodes = [n for n, v in atk_graph.nodes(data=True) if v['x86_Arch'] == 0]
    msteams_nodes = [n for n, v in atk_graph.nodes(data=True) if v['MS_Teams'] == 1]
    gchrome_nodes = [n for n, v in atk_graph.nodes(data=True) if v['G_Chrome'] == 1]
    sql_nodes = [n for n, v in atk_graph.nodes(data=True) if v['SQL'] == 1]
    updated_nodes = [n for n, v in atk_graph.nodes(data=True) if v['Updated'] == 1]
    firewall_nodes = [n for n, v in atk_graph.nodes(data=True) if v['Firewall'] == 1]

    # Get connections between nodes (also needed for initial state)
    connections = []
    for i in atk_graph.nodes():
        for j in atk_graph.neighbors(i):
            connections.append((i, j))

    # Now we create a problem.pddl file
    with open(f'./pddl_files/problem_n{nodes}.pddl', "w") as f:
        # Write domain info and objects
        f.write(f'(define (problem pentest-{nodes})\n')
        f.write('\t(:domain pentest)\n')
        f.write('\t(:objects ' + ' '.join('h' + str(x) for x in all_nodes) + ' - host)\n\n')

        # Write initial conditions
        f.write('\t(:init\n')
        f.write(f'\t\t(attacker-at h{start_node})\n')
        f.write(f'\t\t(compromised h{start_node})\n')
        f.writelines(f'\t\t(has-os h{i} windows)\n' for i in windows_nodes)
        f.writelines(f'\t\t(has-os h{i} mac)\n' for i in mac_nodes)
        f.writelines(f'\t\t(has-os h{i} linux)\n' for i in linux_nodes)
        f.writelines(f'\t\t(has-architecture h{i} x86)\n' for i in x86_nodes)
        f.writelines(f'\t\t(has-architecture h{i} arm)\n' for i in arm_nodes)
        f.writelines(f'\t\t(has-software h{i} msteams)\n' for i in msteams_nodes)
        f.writelines(f'\t\t(has-software h{i} googlechrome)\n' for i in gchrome_nodes)
        f.writelines(f'\t\t(has-software h{i} sql)\n' for i in sql_nodes)
        f.writelines(f'\t\t(updated h{i})\n' for i in updated_nodes)
        f.writelines(f'\t\t(firewall h{i})\n' for i in firewall_nodes)
        f.writelines(f'\t\t(neighbor h{i} h{j})\n' for (i, j) in connections)
        f.write('\t)\n\n')

        # Write goal state
        f.write('\t(:goal\n')
        f.write(f'\t\t(attacker-at h{goal_node})\n')
        f.write('\t)\n)\n')


if __name__ == '__main__':
    # First problem (n=10)- SOLVABLE
    # pddlify_problem(10, 0.4, bayes_seed=12, graph_seed=56, start=0, goal=1, display=True)

    # Second problem (n=10)- SOLVABLE
    # pddlify_problem(20, 0.25, bayes_seed=50, graph_seed=6, start=13, goal=19, display=True)

    # Third problem (n=40)- UNSOLVABLE
    # pddlify_problem(40, 0.1, bayes_seed=37, graph_seed=32, start=4, goal=29, display=True)

    # Fourth problem (n=50) - SOLVABLE
    pddlify_problem(50, 0.1, bayes_seed=43, graph_seed=42, start=18, goal=21, display=True)
